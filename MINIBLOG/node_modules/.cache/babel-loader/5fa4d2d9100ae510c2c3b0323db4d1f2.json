{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect, useReducer } from \"react\";\nimport { db } from \"../firebase/config\";\nimport { updateDoc, doc } from \"firebase/firestore\";\nconst initialState = {\n  loading: null,\n  error: null\n};\n\nconst updateReducer = (state, action) => {\n  switch (action.type) {\n    case \"LOADING\":\n      return {\n        loading: true,\n        error: null\n      };\n\n    case \"UPDATED_DOC\":\n      return {\n        loading: false,\n        error: null\n      };\n\n    case \"ERROR\":\n      return {\n        loading: false,\n        error: action.payload\n      };\n\n    default:\n      return state;\n  }\n};\n\nexport const useUpdateDocument = docCollection => {\n  _s();\n\n  const [response, dispatch] = useReducer(updateReducer, initialState); // deal with memory leak\n\n  const [cancelled, setCancelled] = useState(false);\n\n  const checkCancelBeforeDispatch = action => {\n    if (!cancelled) {\n      dispatch(action);\n    }\n  };\n\n  const updateDocument = async (uid, data) => {\n    checkCancelBeforeDispatch({\n      type: \"LOADING\"\n    });\n\n    try {\n      const docRef = await doc(db, docCollection, uid);\n      console.log(docRef);\n      const updatedDocument = await updateDoc(docRef, data);\n      console.log(updateDocument);\n      checkCancelBeforeDispatch({\n        type: \"UPDATED_DOC\",\n        payload: updatedDocument\n      });\n    } catch (error) {\n      console.log(error);\n      checkCancelBeforeDispatch({\n        type: \"ERROR\",\n        payload: error.message\n      });\n    }\n  };\n\n  useEffect(() => {\n    return () => setCancelled(true);\n  }, []);\n  return {\n    updateDocument,\n    response\n  };\n};\n\n_s(useUpdateDocument, \"aGpufD8as+miNYZKmGUYm2CUF6M=\");","map":{"version":3,"sources":["C:/Users/Eduardo/Documents/JS/react/MINIBLOG/miniblog/src/hooks/useUpdateDocument.js"],"names":["useState","useEffect","useReducer","db","updateDoc","doc","initialState","loading","error","updateReducer","state","action","type","payload","useUpdateDocument","docCollection","response","dispatch","cancelled","setCancelled","checkCancelBeforeDispatch","updateDocument","uid","data","docRef","console","log","updatedDocument","message"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,UAA9B,QAAgD,OAAhD;AACA,SAASC,EAAT,QAAmB,oBAAnB;AACA,SAASC,SAAT,EAAoBC,GAApB,QAA+B,oBAA/B;AAEA,MAAMC,YAAY,GAAG;AACnBC,EAAAA,OAAO,EAAE,IADU;AAEnBC,EAAAA,KAAK,EAAE;AAFY,CAArB;;AAKA,MAAMC,aAAa,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACvC,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,SAAL;AACE,aAAO;AAAEL,QAAAA,OAAO,EAAE,IAAX;AAAiBC,QAAAA,KAAK,EAAE;AAAxB,OAAP;;AACF,SAAK,aAAL;AACE,aAAO;AAAED,QAAAA,OAAO,EAAE,KAAX;AAAkBC,QAAAA,KAAK,EAAE;AAAzB,OAAP;;AACF,SAAK,OAAL;AACE,aAAO;AAAED,QAAAA,OAAO,EAAE,KAAX;AAAkBC,QAAAA,KAAK,EAAEG,MAAM,CAACE;AAAhC,OAAP;;AACF;AACE,aAAOH,KAAP;AARJ;AAUD,CAXD;;AAaA,OAAO,MAAMI,iBAAiB,GAAIC,aAAD,IAAmB;AAAA;;AAClD,QAAM,CAACC,QAAD,EAAWC,QAAX,IAAuBf,UAAU,CAACO,aAAD,EAAgBH,YAAhB,CAAvC,CADkD,CAGlD;;AACA,QAAM,CAACY,SAAD,EAAYC,YAAZ,IAA4BnB,QAAQ,CAAC,KAAD,CAA1C;;AAEA,QAAMoB,yBAAyB,GAAIT,MAAD,IAAY;AAC5C,QAAI,CAACO,SAAL,EAAgB;AACdD,MAAAA,QAAQ,CAACN,MAAD,CAAR;AACD;AACF,GAJD;;AAMA,QAAMU,cAAc,GAAG,OAAOC,GAAP,EAAYC,IAAZ,KAAqB;AAC1CH,IAAAA,yBAAyB,CAAC;AAAER,MAAAA,IAAI,EAAE;AAAR,KAAD,CAAzB;;AAEA,QAAI;AACF,YAAMY,MAAM,GAAG,MAAMnB,GAAG,CAACF,EAAD,EAAKY,aAAL,EAAoBO,GAApB,CAAxB;AAEAG,MAAAA,OAAO,CAACC,GAAR,CAAYF,MAAZ;AAEA,YAAMG,eAAe,GAAG,MAAMvB,SAAS,CAACoB,MAAD,EAASD,IAAT,CAAvC;AAEAE,MAAAA,OAAO,CAACC,GAAR,CAAYL,cAAZ;AAEAD,MAAAA,yBAAyB,CAAC;AACxBR,QAAAA,IAAI,EAAE,aADkB;AAExBC,QAAAA,OAAO,EAAEc;AAFe,OAAD,CAAzB;AAID,KAbD,CAaE,OAAOnB,KAAP,EAAc;AACdiB,MAAAA,OAAO,CAACC,GAAR,CAAYlB,KAAZ;AACAY,MAAAA,yBAAyB,CAAC;AAAER,QAAAA,IAAI,EAAE,OAAR;AAAiBC,QAAAA,OAAO,EAAEL,KAAK,CAACoB;AAAhC,OAAD,CAAzB;AACD;AACF,GApBD;;AAsBA3B,EAAAA,SAAS,CAAC,MAAM;AACd,WAAO,MAAMkB,YAAY,CAAC,IAAD,CAAzB;AACD,GAFQ,EAEN,EAFM,CAAT;AAIA,SAAO;AAAEE,IAAAA,cAAF;AAAkBL,IAAAA;AAAlB,GAAP;AACD,CAvCM;;GAAMF,iB","sourcesContent":["import { useState, useEffect, useReducer } from \"react\";\nimport { db } from \"../firebase/config\";\nimport { updateDoc, doc } from \"firebase/firestore\";\n\nconst initialState = {\n  loading: null,\n  error: null,\n};\n\nconst updateReducer = (state, action) => {\n  switch (action.type) {\n    case \"LOADING\":\n      return { loading: true, error: null };\n    case \"UPDATED_DOC\":\n      return { loading: false, error: null };\n    case \"ERROR\":\n      return { loading: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\nexport const useUpdateDocument = (docCollection) => {\n  const [response, dispatch] = useReducer(updateReducer, initialState);\n\n  // deal with memory leak\n  const [cancelled, setCancelled] = useState(false);\n\n  const checkCancelBeforeDispatch = (action) => {\n    if (!cancelled) {\n      dispatch(action);\n    }\n  };\n\n  const updateDocument = async (uid, data) => {\n    checkCancelBeforeDispatch({ type: \"LOADING\" });\n\n    try {\n      const docRef = await doc(db, docCollection, uid);\n\n      console.log(docRef);\n\n      const updatedDocument = await updateDoc(docRef, data);\n\n      console.log(updateDocument);\n\n      checkCancelBeforeDispatch({\n        type: \"UPDATED_DOC\",\n        payload: updatedDocument,\n      });\n    } catch (error) {\n      console.log(error);\n      checkCancelBeforeDispatch({ type: \"ERROR\", payload: error.message });\n    }\n  };\n\n  useEffect(() => {\n    return () => setCancelled(true);\n  }, []);\n\n  return { updateDocument, response };\n};\n"]},"metadata":{},"sourceType":"module"}