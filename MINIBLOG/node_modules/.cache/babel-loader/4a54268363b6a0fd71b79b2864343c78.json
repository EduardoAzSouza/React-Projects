{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from \"react\";\nimport { db } from \"../firebase/config\";\nimport { collection, query, orderBy, onSnapshot, where } from \"firebase/firestore\";\nexport const useFetchDocuments = function (docCollection) {\n  _s();\n\n  let search = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let uid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const [documents, setDocuments] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(null); // deal with memory leak\n\n  const [cancelled, setCancelled] = useState(false);\n  useEffect(() => {\n    async function loadData() {\n      if (cancelled) {\n        return;\n      }\n\n      setLoading(true);\n      const collectionRef = await collection(db, docCollection);\n\n      try {\n        let q;\n\n        if (search) {\n          q = await query(collectionRef, where(\"tags\", \"array-contains\", search), orderBy(\"createdAt\", \"desc\"));\n        } else if (uid) {\n          q = await query(collectionRef, where(\"uid\", \"==\", uid), orderBy(\"createdAt\", \"desc\"));\n        } else {\n          q = await query(collectionRef, orderBy(\"createdAt\", \"desc\"));\n        }\n\n        await onSnapshot(q, querySnapshot => {\n          setDocuments(querySnapshot.docs.map(doc => ({\n            id: doc.id,\n            ...doc.data()\n          })));\n        });\n      } catch (error) {\n        console.log(error);\n        setError(error.message);\n      }\n\n      setLoading(false);\n    }\n\n    loadData();\n  }, [docCollection, search, uid, cancelled]);\n  console.log(documents);\n  useEffect(() => {\n    return () => setCancelled(true);\n  }, []);\n  return {\n    documents,\n    loading,\n    error\n  };\n};\n\n_s(useFetchDocuments, \"oHQtMVeLQvU17FI2wc7iUGDhIAM=\");","map":{"version":3,"sources":["C:/Users/Eduardo/Documents/JS/react/MINIBLOG/miniblog/src/hooks/useFetchDocuments.js"],"names":["useState","useEffect","db","collection","query","orderBy","onSnapshot","where","useFetchDocuments","docCollection","search","uid","documents","setDocuments","error","setError","loading","setLoading","cancelled","setCancelled","loadData","collectionRef","q","querySnapshot","docs","map","doc","id","data","console","log","message"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AACA,SAASC,EAAT,QAAmB,oBAAnB;AACA,SACEC,UADF,EAEEC,KAFF,EAGEC,OAHF,EAIEC,UAJF,EAKEC,KALF,QAMO,oBANP;AAQA,OAAO,MAAMC,iBAAiB,GAAG,UAACC,aAAD,EAA8C;AAAA;;AAAA,MAA9BC,MAA8B,uEAArB,IAAqB;AAAA,MAAfC,GAAe,uEAAT,IAAS;AAC7E,QAAM,CAACC,SAAD,EAAYC,YAAZ,IAA4Bb,QAAQ,CAAC,IAAD,CAA1C;AACA,QAAM,CAACc,KAAD,EAAQC,QAAR,IAAoBf,QAAQ,CAAC,IAAD,CAAlC;AACA,QAAM,CAACgB,OAAD,EAAUC,UAAV,IAAwBjB,QAAQ,CAAC,IAAD,CAAtC,CAH6E,CAK7E;;AACA,QAAM,CAACkB,SAAD,EAAYC,YAAZ,IAA4BnB,QAAQ,CAAC,KAAD,CAA1C;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACd,mBAAemB,QAAf,GAA0B;AACxB,UAAIF,SAAJ,EAAe;AACb;AACD;;AAEDD,MAAAA,UAAU,CAAC,IAAD,CAAV;AAEA,YAAMI,aAAa,GAAG,MAAMlB,UAAU,CAACD,EAAD,EAAKO,aAAL,CAAtC;;AAEA,UAAI;AACF,YAAIa,CAAJ;;AAEA,YAAIZ,MAAJ,EAAY;AACVY,UAAAA,CAAC,GAAG,MAAMlB,KAAK,CACbiB,aADa,EAEbd,KAAK,CAAC,MAAD,EAAS,gBAAT,EAA2BG,MAA3B,CAFQ,EAGbL,OAAO,CAAC,WAAD,EAAc,MAAd,CAHM,CAAf;AAKD,SAND,MAMO,IAAIM,GAAJ,EAAS;AACdW,UAAAA,CAAC,GAAG,MAAMlB,KAAK,CACbiB,aADa,EAEbd,KAAK,CAAC,KAAD,EAAQ,IAAR,EAAcI,GAAd,CAFQ,EAGbN,OAAO,CAAC,WAAD,EAAc,MAAd,CAHM,CAAf;AAKD,SANM,MAMA;AACLiB,UAAAA,CAAC,GAAG,MAAMlB,KAAK,CAACiB,aAAD,EAAgBhB,OAAO,CAAC,WAAD,EAAc,MAAd,CAAvB,CAAf;AACD;;AAED,cAAMC,UAAU,CAACgB,CAAD,EAAKC,aAAD,IAAmB;AACrCV,UAAAA,YAAY,CACVU,aAAa,CAACC,IAAd,CAAmBC,GAAnB,CAAwBC,GAAD,KAAU;AAC/BC,YAAAA,EAAE,EAAED,GAAG,CAACC,EADuB;AAE/B,eAAGD,GAAG,CAACE,IAAJ;AAF4B,WAAV,CAAvB,CADU,CAAZ;AAMD,SAPe,CAAhB;AAQD,OA3BD,CA2BE,OAAOd,KAAP,EAAc;AACde,QAAAA,OAAO,CAACC,GAAR,CAAYhB,KAAZ;AACAC,QAAAA,QAAQ,CAACD,KAAK,CAACiB,OAAP,CAAR;AACD;;AAEDd,MAAAA,UAAU,CAAC,KAAD,CAAV;AACD;;AAEDG,IAAAA,QAAQ;AACT,GA9CQ,EA8CN,CAACX,aAAD,EAAgBC,MAAhB,EAAwBC,GAAxB,EAA6BO,SAA7B,CA9CM,CAAT;AAgDAW,EAAAA,OAAO,CAACC,GAAR,CAAYlB,SAAZ;AAEAX,EAAAA,SAAS,CAAC,MAAM;AACd,WAAO,MAAMkB,YAAY,CAAC,IAAD,CAAzB;AACD,GAFQ,EAEN,EAFM,CAAT;AAIA,SAAO;AAAEP,IAAAA,SAAF;AAAaI,IAAAA,OAAb;AAAsBF,IAAAA;AAAtB,GAAP;AACD,CA/DM;;GAAMN,iB","sourcesContent":["import { useState, useEffect } from \"react\";\nimport { db } from \"../firebase/config\";\nimport {\n  collection,\n  query,\n  orderBy,\n  onSnapshot,\n  where,\n} from \"firebase/firestore\";\n\nexport const useFetchDocuments = (docCollection, search = null, uid = null) => {\n  const [documents, setDocuments] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(null);\n\n  // deal with memory leak\n  const [cancelled, setCancelled] = useState(false);\n\n  useEffect(() => {\n    async function loadData() {\n      if (cancelled) {\n        return;\n      }\n\n      setLoading(true);\n\n      const collectionRef = await collection(db, docCollection);\n\n      try {\n        let q;\n\n        if (search) {\n          q = await query(\n            collectionRef,\n            where(\"tags\", \"array-contains\", search),\n            orderBy(\"createdAt\", \"desc\")\n          );\n        } else if (uid) {\n          q = await query(\n            collectionRef,\n            where(\"uid\", \"==\", uid),\n            orderBy(\"createdAt\", \"desc\")\n          );\n        } else {\n          q = await query(collectionRef, orderBy(\"createdAt\", \"desc\"));\n        }\n\n        await onSnapshot(q, (querySnapshot) => {\n          setDocuments(\n            querySnapshot.docs.map((doc) => ({\n              id: doc.id,\n              ...doc.data(),\n            }))\n          );\n        });\n      } catch (error) {\n        console.log(error);\n        setError(error.message);\n      }\n\n      setLoading(false);\n    }\n\n    loadData();\n  }, [docCollection, search, uid, cancelled]);\n\n  console.log(documents);\n\n  useEffect(() => {\n    return () => setCancelled(true);\n  }, []);\n\n  return { documents, loading, error };\n};\n"]},"metadata":{},"sourceType":"module"}